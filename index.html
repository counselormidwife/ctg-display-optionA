<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>CTG / NST Display</title>

<style>
html, body {
    margin: 0; padding: 0;
    width: 100%; height: 100%;
    background: #000; overflow: hidden;
    font-family: Arial, Helvetica, sans-serif;
}

#headerBox {
    position: absolute;
    top: 40px; left: 12px;
    z-index: 9999;
    background: rgba(0,0,0,0.7);
    padding: 8px 12px;
    border-radius: 4px;
    border: 1px solid #777;
    min-width: 260px;
}

#headerText { font-size: 18px; font-weight: bold; color: #fff; }
#subheaderText { margin-top: 4px; font-size: 14px; color: #aaffaa; }

#container {
    position: absolute; inset: 0;
    display: flex; flex-direction: column;
}

canvas { display: block; width: 100%; }

#fhrCanvas { flex: 7; background: #000; }
#ucCanvas  { flex: 3; background: #000; border-top: 2px solid #555; }
</style>
</head>

<body>
<div id="headerBox">
  <div id="headerText">MONITOR</div>
  <div id="subheaderText">â€”</div>
</div>

<div id="container">
  <canvas id="fhrCanvas"></canvas>
  <canvas id="ucCanvas"></canvas>
</div>

<script>
const params = new URLSearchParams(window.location.search);

function parseSeries(raw) {
  if (!raw) return [];
  // CSV path
  if (raw.indexOf(",") !== -1) return raw.split(",").map(v => parseInt(v, 10) || 0);
  // packed base36 path ('.' separated)
  return raw.split(".").map(v => parseInt(v, 36) || 0);
}

function parseMarkers(raw) {
  if (!raw) return [];
  // old format: "t:CODE;..."
  if (raw.indexOf(":") !== -1) {
    return raw.split(";").map(m => {
      const p = m.split(":");
      return { t: parseInt(p[0],10) || 0, code: p[1] || "X" };
    });
  }
  // packed format: "dtCODE.dtCODE" where dt is base36 offset in-window
  // We'll map to normalized x by dt/window
  return raw.split(".").map(m => {
    const dt = parseInt(m.slice(0, -1), 36) || 0;
    const code = m.slice(-1) || "X"; // M/A/C/X; decels come as D? (we encode DE/DL/DV upstream as "X" here for now)
    return { dt, code };
  });
}

const mode    = params.get("mode") || "IDLE";
const patient = params.get("pat")  || "";
const ga      = params.get("ga")   || "";
const iupc    = (params.get("iupc") === "1");

const fhr = parseSeries(params.get("f"));
const uc  = parseSeries(params.get("u"));
const mk  = parseMarkers(params.get("k"));

const nst = params.get("nst") || "";
const e   = parseInt(params.get("e") || "0", 10) || 0;
const T   = parseInt(params.get("T") || "0", 10) || 0;

let title = "MONITOR";
if (mode === "NST") title = "NST MONITOR";
else if (mode === "CTG") title = "CTG MONITOR";
else if (iupc) title = "IUPC MONITOR";

document.getElementById("headerText").innerText = `${title}  |  ${patient} ${ga}w`;
document.getElementById("subheaderText").innerText = (mode === "NST") ? `NST: ${nst}   ${e}/${T}s` : "";

// canvases
const fhrC = document.getElementById("fhrCanvas");
const ucC  = document.getElementById("ucCanvas");

function resize() {
  fhrC.width = innerWidth; ucC.width = innerWidth;
  fhrC.height = fhrC.clientHeight; ucC.height = ucC.clientHeight;
}
addEventListener("resize", resize); resize();

const fctx = fhrC.getContext("2d");
const uctx = ucC.getContext("2d");

function drawGrid(ctx, min, max, step, labelEvery, label, emphasize=false) {
  const h = ctx.canvas.height;
  const scale = h / (max - min);

  ctx.strokeStyle = emphasize ? "#888" : "#666";
  ctx.lineWidth = emphasize ? 2 : 1.5;
  ctx.fillStyle = "#ddd";
  ctx.font = "12px Arial";

  for (let v = min; v <= max; v += step) {
    const y = h - (v - min) * scale;
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(ctx.canvas.width, y); ctx.stroke();
    if (v % labelEvery === 0) ctx.fillText(String(v), 6, y - 2);
  }
  ctx.fillStyle = "#aaa";
  ctx.fillText(label, 6, 14);
}

function drawWave(ctx, data, min, max, baseColor, highlightColor) {
  if (!data.length) return;
  const h = ctx.canvas.height;
  const scaleY = h / (max - min);
  const stepX = ctx.canvas.width / (data.length - 1);

  ctx.strokeStyle = baseColor;
  ctx.lineWidth = 4.5;
  ctx.lineJoin = "round";
  ctx.beginPath();
  data.forEach((v, i) => {
    const x = i * stepX;
    const y = h - (v - min) * scaleY;
    i ? ctx.lineTo(x,y) : ctx.moveTo(x,y);
  });
  ctx.stroke();

  ctx.strokeStyle = highlightColor;
  ctx.lineWidth = 2;
  ctx.beginPath();
  data.forEach((v, i) => {
    const x = i * stepX;
    const y = h - (v - min) * scaleY;
    i ? ctx.lineTo(x,y) : ctx.moveTo(x,y);
  });
  ctx.stroke();
}

function drawMarkers(ctx, markers, y) {
  const n = fhr.length || 1;
  markers.forEach(m => {
    let c = "#aaa";
    // packed markers use dt; older markers use t
    let xFrac = 0;
    if (typeof m.dt === "number") xFrac = m.dt / Math.max(n-1, 1);
    else xFrac = (m.t || 0) / Math.max(n-1, 1);

    if (m.code === "M") c = "#4aa3ff";
    if (m.code === "A") c = "#66ff66";
    // decels are still coming through as X in packed mode unless we expand codes later
    ctx.fillStyle = c;
    ctx.fillRect(xFrac * ctx.canvas.width, y, 3, 16);
  });
}

fctx.clearRect(0,0,fhrC.width,fhrC.height);
uctx.clearRect(0,0,ucC.width,ucC.height);

drawGrid(fctx, 60, 200, 10, 20, "FHR (bpm)", true);
drawWave(fctx, fhr, 60, 200, "#003300", "#00ff00");

if (iupc) {
  drawGrid(uctx, 0, 100, 10, 20, "Uterine Pressure (mmHg)", true);
  drawWave(uctx, uc, 0, 100, "#444444", "#ffffff");
} else {
  drawGrid(uctx, 0, 100, 20, 50, "Uterine Activity (relative)", false);
  drawWave(uctx, uc, 0, 100, "#333333", "#cccccc");
}

drawMarkers(fctx, mk, 12);
drawMarkers(uctx, mk, 12);
</script>
</body>
</html>
